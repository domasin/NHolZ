<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <!--
      The Regole d'inferenza
 parameters will be replaced with the
      document title extracted from the <h1> element or
      file name, if there is no <h1> heading
    -->
    <title>Regole d'inferenza
</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://code.jquery.com/jquery-1.8.0.js"></script>
    <script src="https://netdna.bootstrapcdn.com/twitter-bootstrap/2.2.1/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
	
    <link href="https://netdna.bootstrapcdn.com/twitter-bootstrap/2.2.1/css/bootstrap-combined.min.css" rel="stylesheet">
    <link type="text/css" rel="stylesheet" href="content/style.css" />
    <script src="content/tips.js" type="text/javascript"></script>
    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="container" >
      <div class="row" style="margin-top:30px;">
        <div class="span1"></div>
        <div class="span10" id="main">
          <h1>Regole d'inferenza</h1>
<p>Questa appendice fornisce una descrizione delle regole d'inferenza</p>
<h2>Regole primitive</h2>
<p><span class="math">\(\dfrac
{t}
{\vdash t = t}
\textsf{ refl_conv}\)</span></p>
<p>Questa &egrave; la regola di riflessivit&agrave; per l'uguaglianza. Prende un
termine, e restituisce un teorema che afferma che il termine &egrave; uguale a
se stesso, senza alcuna assunzione. Non ci sono restrizioni al termine fornito.</p>
<p>Si veda anche: sym_conv, sym_rule, trans_rule.</p>
<p><span class="math">\(\dfrac
{(\lambda x. t)\ s}
{\vdash (\lambda x. t)\ s = t[s/x]}
\textsf{ beta_conv}\)</span></p>
<p>Questa &egrave; la conversione di beta riduzione. Prende una lambda astrazione
applicata a un termine, e restituisce un teorema che afferma che l'applicazione
&egrave; uguale al corpo della lambda astrazione con tutte le occorrenze della
variabile legata sostituita con l'argomento dell'apllicazione, senza alcuna
assunzione.</p>
<p><span class="math">\(\dfrac
{A_1 \vdash f_1 = f_2 \qquad  A_2 \vdash t_1 = t_2}
{A_1 \cup A_2 \vdash f_1\ t_1 = f_2\ t_2}
\textsf{ mk_comb_rule}\)</span></p>
<p>Questa &egrave; la regola di congruenza di eguaglianza per l'applicazione di
funzione. Prende due teoremi di equivalenza, e applica i corrispondenti lati del
primo teorema a quelli del secondo, unendo le loro assunzioni. I lati sinistro e
destro del primo teorema devono essere funzioni con il tipo del dominio uguale al
tipo dei lati sinistro e destro del secondo teorema.</p>
<p>Si veda anche: mk_comb1_rule, mk_comb2_rule, mk_bin_rule, mk_abs_rule.</p>
<p><span class="math">\(\dfrac
{x \qquad A \vdash t_1 = t_2}
{A \vdash (\lambda x.\ t_1 = t_2)}
\textsf{ mk_abs_rule}\)</span></p>
<p>(per x non libera in A)</p>
<p>Questa &egrave; la regola di congruenza di eguaglianza per la lambda astrazione.
Prende una variabile e un teorema di uguaglianza, e astrae la variabile da
entrambi i lati del teorema. La variabile non deve occorrere libera nelle
assunzioni del teorema fornito.</p>
<p>Si veda anche: mk_comb_rule.</p>
<p><span class="math">\(\dfrac
{p}
{p \vdash p}
\textsf{ assume_rule}\)</span></p>
<p>Questa &egrave; la regola di assunzione. Prende un termine booleano, e restituisce
un teorema che afferma che il termine vale sotto la singola assunzione del termine
stesso.</p>
<p>Si veda anche: add_asm_rule.</p>
<p><span class="math">\(\dfrac
{p \qquad A \vdash q}
{A \setminus \{p\} \vdash p \Rightarrow q}
\textsf{ disch_rule}\)</span></p>
<p>Questa &egrave; la regola d'intrdouzone dell'implicazione. Prende un termine booleano
e un teorema, rimuove il termine (se presente) dalle assunzioni del teorema e lo
aggiunge come antecedente della conclusione. Si noti che il termine non deve essere
presente nelle assunzioni del teorema fornito perch&eacute; la regola abbia
successo.</p>
<p>Si veda anche: undisch_rule, mp_rule.</p>
<p><span class="math">\(\dfrac
{A_1 \vdash p \Rightarrow q \qquad A_2 \vdash p}
{A_1 \cup A_2 \vdash q}
\textsf{ mp_rule}\)</span></p>
<p>Questa &egrave; la regola di modus ponens. Prende un teorema di implicazione ed
un secondo teorema, dove l'antecendente del teorema di implicazione &egrave;
alfa-equivalente alla conclusione del secondo teorema. Restituisce un teorema che
afferma che vale il conseguente del teorema di implicazione, sotto l'unione delle
assunzioni dei teoremi forniti.</p>
<p>Si veda anche: eq_mp_rule, disch_rule, undisch_rule, prove_asm_rule.</p>
<p><span class="math">\(\dfrac
{A_1 \vdash p \Leftrightarrow q \qquad A_2 \vdash p}
{A_1 \cup A_2 \vdash q}
\textsf{ eq_mp_rule}\)</span></p>
<p>Questa &egrave; la regola di modus ponens per l'uguaglianza. Prende un teorema di
uguaglianza e un secondo teorema, dove il lato sinistro del teorema &egrave;
alf-equivalente alla conclusione del secondo teorema. Restituisce un teorema che
aggerma la parte destra del teorema di uguaglianza vale, sotto l'unione delle
assunzioni dei teoremi forniti.</p>
<p>Si veda anche: mp_rule, eq_imp_rule1, eq_imp_rule2, imp_antisym_rule.</p>
<p><span class="math">\(\dfrac
{[(x_1,t_1);(x_2,t_2);\dots] \qquad   A \vdash p}
{A[t_1/x_1,t_2/x_2,\dots] \vdash p[t_1/x_1,t_2/x_2,\dots]}
\textsf{ inst_rule}\)</span></p>
<p>Questa &egrave; la regola d'istanziazione della variabile. Prende una lista di
instanziazioni di variabili e un teorema, ed esegue una singola instanziazione
parallela delle variabili libere nelle assunzioni e nella conclusione del teorema,
secondo la lista di instanziazioni. Tutte le occorrenze libere di elementi nel dominio
della lista di instanziazione sono sostituite nel teorema. Ciascun elemento del dominio
della lista di instanziazione deve essere una variabile, e ciascun elemento nel rango
deve avere lo stesso tipo del corrispondente elemento del dominio.</p>
<p>Le variabili legate nel teorema risultante sono rinominate a seconda delle
necessit&agrave; per evitare catture di variabili. Si noti che gli elementi della
lista che non possono essere applicati sono semplicemente ignorati, cos&igrave;
come lo sono gli elementi ripetuti per una data variabile (oltre al primo elemento).
Se nessun elemento della lista soddisfa i criteri, allora il teorema risultante
&egrave; lo stesso del teorema in input.</p>
<p>Si veda anche: inst_type_rule, subs_rule, subst_rule.</p>
<p><span class="math">\(\dfrac
{[(tv_1,ty_1);(tv_2,ty_2);\dots] \qquad   A \vdash p}
{A[ty_1/tv_1,ty_2/tv_2,\dots] \vdash p[ty_1/tv_1,ty_2/tv_2,\dots]}
\textsf{ inst_type_rule}\)</span></p>
<p>Questa &egrave; la regola d'istanziazione delle variabili di tipo. Prende una lista di
instanziazioni di variabili di tipo e un teorema, ed esegue una singola instanziazione
parallela delle variabili di tipo nelle assunzioni e nella conclusione del teorema, secondo
la lista di instanziazione. Tutte le occorrenze di elementi nel dominio della lista
di instanziazione sono sostituite nel teorema. Ciascun elemento del dominio della
lista deve essere una variabile di tipo.</p>
<p>Le variabili legate nel teorema risultante sono rinominate a seconda delle
necessit&agrave; per evitare catture di variabili. Si noti che gli elementi della
lista che non possono essere applicati sono semplicemente ignorati, cos&igrave;
come lo sono gli elementi ripetuti per una data variabile (oltre al primo elemento).
Se nessun elemento della lista soddisfa i criteri, allora il teorema risultante
&egrave; lo stesso del teorema in input.</p>
<p>Si veda anche: inst_rule.</p>
<h2>Eguaglianza</h2>
<p><span class="math">\(\dfrac
{A \vdash f_1 = f_2 \qquad t}
{A \vdash f_1\ t = f_2\ t}
\textsf{ mk_comb1_rule}\)</span></p>
<p>Questa &egrave; la regola di congruenza di eguaglianza di funzioni per l'applicazione di
funzioni. Prende un teorema di equivalenza su funzioni e un termine, e fornisce
il termine come argomento a ciascun lato del teorema. Il tipo del termine fornito
deve essere lo stesso del tipo del dominio delle funzioni.</p>
<p>Si veda anche: mk_comb2_rule, mk_comb_rule.</p>
<p><span class="math">\(\dfrac
{f \qquad  A \vdash t_1 = t_2}
{A \vdash f\ t_1 = f\ t_2}
\textsf{ mk_comb2_rule}\)</span></p>
<p>Questa &egrave; la regola di congruenza di eguaglianza di argomenti per l'applicazione di
funzioni. Prende un termine funzione e un teorema di uguaglianza, ed applica la
funzione a ciascun lato del teorema. Il tipo del dominio della funzione fornita deve
essere lo stesso del tipo dei lati sinitro e destro del teorema.</p>
<p>Si veda anche: mk_comb1_rule, mk_comb_rule.</p>
<p><span class="math">\(\dfrac
{A_1 \vdash t_1 = t_2 \qquad  A_2 \vdash t_2 = t_3}
{A_1 \cup A2 \vdash t_1 = t_3}
\textsf{ trans_rule}\)</span></p>
<p>Questa &egrave; la regola di transitivit&agrave; per l'uguaglianza. Prende
due teoremi di uguaglianza, dove il lato destro del primo teorema &egrave;
lo stesso (modulo alfa-equivalenza) del lato sinistro del secondot. Restituisce
un teorema che afferma che il lato sinistro del primo teorema uguaglia il
lato destro del secondo teorema, sotto l'unione delle assunzioni dei due
teoremi.</p>
<p>Si veda anche: list_trans_rule, refl_conv, sym_rule, imp_trans_rule.</p>
<p><span class="math">\(\dfrac
{A \vdash t_1 = t_2}
{A \vdash t_2 = t_1}
\textsf{ sym_rule}\)</span></p>
<p>Questa &egrave; la regola di simmetria per l'uguaglianza. Scambia il lato
sinistro con il destro nel teorema di uguaglianza fornito.</p>
<p>Si veda anche: sym_conv, refl_conv, trans_rule.</p>
<p><span class="math">\(\dfrac
{A \vdash f = (\lambda v.\ t)  \qquad s}
{A \vdash f\ s = t[s/v]}
\textsf{ app_beta_rhs_rule}\)</span></p>
<p>Questa regola &egrave; utilizzata per espandere una funzione definita in termini
di una lambda astrazione. Prende un teorema di uguaglianza e un termine, dove
la parte destra del teorema &egrave; una lambda astrazione con una variabile
legata dello stesso tipo del termine argomento. Restituisce un teorema che
afferma che l'argomento sinistro del teorema applicato al termine in input
&egrave; uguale alla beta riduzione della lambda astrazione applicata al termine
in input.</p>
<p><strong>list_app_beta_rhs_rule</strong></p>
<p>da documentare...</p>
<p><span class="math">\(\dfrac
{A \vdash (\lambda v_1. t_1) = (\lambda v_2. t_2)  \qquad s}
{A \vdash t_1[s/v_1] = t_2[s/v_2]}
\textsf{ app_beta_rule}\)</span></p>
<p>Si veda anche: app_beta_rhs_rule.</p>
<p><strong>list_app_beta_rule</strong></p>
<p>Da documentare...</p>
<p><span class="math">\(\dfrac
{t' \qquad t}
{\vdash t = t'}
\textsf{ alpha_link_conv}\)</span></p>
<p>Questa &egrave; la regola di conversione alfa linking. Prende due termini
alfa-equivalentei e restituisce un terorema che afferma che il secondo &egrave;
uguale al primo, senza alcuna assunzione. Fallisce se i termini forniti non sono
alfa equivalenti.</p>
<p><span class="math">\(\dfrac
{y \qquad \lambda x.\ t}
{\vdash (\lambda x.\ t) = (\lambda y.\ t[y/x])}
\textsf{ alpha_conv}\)</span></p>
<p>Questa &egrave; la regola di alfa conversione. Sostituisce la variabile legata
e tutte le sue occorrenze nel termine di lambda astrazione  fornito (il secondo
argomento) con la variabile fornita (come primo argomento).</p>
<p>Si veda anche alpha_link_conv.</p>
<p><span class="math">\(\dfrac
{A_1 \vdash s_1 = t_1 \qquad A_2 \vdash s_2 = t_2 \qquad \dots \qquad t}
{A_1 \cup A_2 \cup \dots \vdash t = t[t_1/s_1,t_2/s_2,\dots] }
\textsf{ subs_conv}\)</span></p>
<p>Questa &egrave; la conversione di sostituzione base. Prende una lista di
teoremi di eguaglianza e un termine, e trasofrma il termine eseguendo una
singola sostituzione parallela di tutti i suoi sottotermini liberi secondo
i teoremi di eguaglianza. Tutto le occorrenze libere dei lati sinistri dei
teoremi di eguaglianza nel termine vegono rimpiazzate. Il teorema risultante
ha l'unione delle assunzioni di tutti i teoremi forniti (indipendentemente
dal fatto che esse si applichino al teorema).</p>
<p>Le variabili legate nel lato destro del teorema risultante sono rinominate
a seconda delle necessit&agrave; per evitare catture di variabili. Si noti
che se uno dei lati sinistri dei teorei di uguaglianza occorre libero
in uno degli altri, allora viene usato di preferenza il teorema con il lato
sinistro pi&ugrave; ampio, e se due teoremi di uguaglianza hanno lati sinistri
alfa-equivalenti, allora di preferenza &egrave; usato di preferenza il primo
teorema nella lisa. Se nessuno dei teoremi di eguaglianza pu&ograve; essere
usato, allora il lato destro del teorema risultante &egrave; lo stesso del
suo lato sinistro.</p>
<p>Si veda anche: subs_rule, subst_conv, inst_rule.</p>
<p><span class="math">\(\dfrac
{A_1 \vdash s_1 = t_1 \qquad A_2 \vdash s_2 = t_2 \qquad \dots \qquad A \vdash t}
{A_1 \cup A_2 \cup \dots \cup A \vdash t = t[t_1/s_1,t_2/s_2,\dots] }
\textsf{ subs_rule}\)</span></p>
<p>Questa &egrave; la regola di sostituzione di base. Prende una lista di
teoremi di equivalenza e un teorema, ed esegue una singola sostituzione
parallela dei sottotermini liberi nella conclusione del teorema secondo i
teoremi di equivalenza. Tutte le occorrenze libere dei lati sinistri dei
teoremi di equivalenza nel teorema vengono rimpiazzate. Il teorema risultante
ha l'unione di tutte le assunzioni di tutti i teoremi forniti (indipendentemente
dal fatto che questi si applichino o meno al teorema fornito).</p>
<p>Le variabili legate nel teorema risultante sono rinominate
a seconda delle necessit&agrave; per evitare catture di variabili. Si noti
che se uno dei lati sinistri dei teorei di uguaglianza occorre libero
in uno degli altri, allora viene usato di preferenza il teorema con il lato
sinistro pi&ugrave; ampio, e se due teoremi di uguaglianza hanno lati sinistri
alfa-equivalenti, allora di preferenza &egrave; usato di preferenza il primo
teorema nella lisa. Se nessuno dei teoremi di eguaglianza pu&ograve; essere
usato, allora la conclusione del teorema risultante &egrave; la stessa
dell'input.</p>
<p>Si veda anche: subs_conv, subst_rule, inst_rule.</p>
<p><span class="math">\(\dfrac
{(v_1, A_1 \vdash s_1 = t_1) \qquad (v_2, A_2 \vdash s_2 = t_2) \qquad \dots \qquad t \qquad t[s_1/v_1,s_2/v_2,\dots]}
{A_1 \cup A_2 \cup \dots \vdash t = t[s_1/v_1,s_2/v_2,\dots] = t[t_1/v_1,t_2/v_2,\dots]}
\textsf{ subst_conv}\)</span></p>
<p>Questa &egrave; la conversione di sostituzione tramite template. Prende uno
schema di sostituzione (nella forma di una lista di associazione e un termine
template) seguito da un termine principale, e trasforma il termine principale
con una singola sostituzione parallela di tutti i suoi sottotermini liberi, secondo
lo schema di sostituzione. Il termine template determina quali occorrenze
libere dei lati sinistri del teorema di equivalenza nel termine principale sono
rimpiazzate, e riflette la struttura sintattica del termine, eccetto che per
l'avere atomi variabili template al posto dei sottotoermini a causa del
rimpiazzamento. La lista di associazione mappa ogni variabile template a un
teorema di equivalenza, con il lato sinistro del teorema di equivalenza per
il sottotermine del termine principale originale e il lato destro per il
sottotermine che lo rimpiazza. Il teorema risultante ha l'unione delle
assunzioni di tutti i teoremi forniti (indipenentemente dal fatto che essi
si applichino al template fornito).</p>
<p>Le variabili legate nel teorema risultante sono rinominate secondo le
necessit&agrave; per evitare catture di variabili. Si noti che se due elementi
appaiono nella lista di associazione per la stessa variabile template, allora
viene usato il primo elemento, e che elementi per variabili che non appaiono
nel template sono ignorate. Se nessun elemento pu&ograve; essere applicato,
allora il lato destro della conclusione del teorema risultante &egrave;
lo stesso del suo lato sinistro.</p>
<p>Si veda anche: subst_rule, subs_conv, inst_rule.</p>
<p><span class="math">\(\dfrac
{(v_1, A_1 \vdash s_1 = t_1) \qquad (v_2, A_2 \vdash s_2 = t_2) \qquad \dots \qquad t \qquad A \vdash t[s_1/v_1,s_2/v_2,\dots]}
{A_1 \cup A_2 \cup \dots \cup A \vdash t = t[t_1/v_1,t_2/v_2,\dots]}
\textsf{ subst_rule}\)</span></p>
<p>Questa &egrave; la regola di sostituzione tramite template. Prende uno
schema di sostituzione (nella forma di una lista di associazione e di
un termine template) seguito da un teorema, ed esegue una singola sostituzione
parallela di tutti i sottotermini liberi nella conclusione del teorema, secondo
lo schema di sostituzione. Il termine template determina quali occorrenze
libere dei lati sinistri del teorema di equivalenza vengono rimpiazzate nella
conclusione del teorema, eccetto che variabili atomiche template al posto
dei sottotermini a causa del rimpiazzamento. La lista di associazione mappa
ogni variabile template a un teorema di equivalenza, con il lato sinistro del
teorema di equivalenza per il sottotermine del teorema originale fornito e il
lato destro per il sottotermine che viene sostituito. Il teorema risultante
ha l'unione delle assunzioni di tutti i teoremi forniti (indipenentemente dal
fatto che essi si applichino al template fornito).</p>
<p>Le variabili di astrazione nel teorema risultante sono rinominate secondo le
necessit&agrave; per evitare catture di variabili. Si noti che se due elementi
appaiono nella lista di associazione per la stessa variabile template, allora
viene usato il primo elemento, e che elementi per variabili che non appaiono
nel template sono ignorate. Se nessun elemento pu&ograve; essere applicato,
allora il lato destro della conclusione del teorema risultante &egrave;
lo stesso del suo lato sinistro.</p>
<p>Si veda anche: subst_conv, subs_rule, inst_rule.</p>
<p><strong>conv_rule</strong></p>
<p>Regola di metaconversione.</p>
<p>Prende una regola di conversione <code>term -&gt; thm</code> e un teorema e applica <code>eq_mp_rule</code> alla conclusione
convertita e al teorema stesso.</p>
<h2>| Bool.add_asm_rule</h2>
<p>Questa &egrave; la regola di aggiunta di un'assunzione. Prende un termine booleano
e un teorema e restituisce lo stesso teorema ma con il termine fornito aggiunto
alle sue assunzioni. Il teorema restituito in output coincide con quello fornito in input
se il termine &egrave; gi&agrave; presente nelle assunzioni.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="pp">#I</span> <span class="s">&quot;../bin/netstandard2.0&quot;</span>
<span class="pp">#r</span> <span class="s">&quot;nholz.dll&quot;</span>
<span class="k">open</span> <span onmouseout="hideTip(event, 'fs1', 1)" onmouseover="showTip(event, 'fs1', 1)" class="id">HOL</span>

<span onmouseout="hideTip(event, 'fs2', 2)" onmouseover="showTip(event, 'fs2', 2)" class="fn">add_asm_rule</span>

<span class="c">//  `q`   A |- p</span>
<span class="c">//  ------------</span>
<span class="c">//  A u {q} |- p</span>
</code></pre>
<h2>| Bool.bspec_rule</h2>
<p>Questa &egrave; la regola di eliminazione del quantifcatore universale con
beta-riduzione. Toglie il quantificatore universale pi&ugrave; esterno dal
teorema fornito, e sostituisce nel corpo ogni occorrenza della variabile legata
eliminata con il termine fornito. Se il termine in input &egrave; una lambda
astrazione, esegue anche la beta riduzione di ogni occorrenza sostituita che
sia applicata ad un argomento. Il tipo del termine fornito deve essere uguale
al tipo della variabile legata eliminata.</p>
<p>Si veda anche: spec_rule, list_spec_rule, spec_all_rule, gen_rule.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs3', 3)" onmouseover="showTip(event, 'fs3', 3)" class="fn">bspec_rule</span>

<span class="c">//         `\y. t`   A |- !x. p</span>
<span class="c">//   --------------------------------</span>
<span class="c">//   A |- p[ \y.t / x; t[s/y] / x s ]</span>
</code></pre>
<h2>| BoolClass.ccontr_rule</h2>
<p>Questa &egrave; la regola contraddizione della logica classica. Prende un termine
booleano e un teorema con falso come sua conclusione. Restituisce un teorema con
il termine fornito come sua conclusione, e con le stesse assunzioni del teorema
fornito ma con la negazione logica del termine fornito rimossa. Si noti che la
negazione logica del termine fornito non deve essere nelle assunzioni del teorema
affinch&eacute; questa regola abbia successo.</p>
<p>Si veda anche: contr_rule, deduct_contrapos_rule.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs4', 4)" onmouseover="showTip(event, 'fs4', 4)" class="fn">ccontr_rule</span>

<span class="c">//  `p`   A |- false</span>
<span class="c">//  ----------------</span>
<span class="c">//    A\{~p} |- p</span>
</code></pre>
<h2>| Bool.choose_rule</h2>
<p>Questa &egrave; la regola di eliminazione del quantificatore esistenziale.
Rimuove, dalle assunzioni di un teorema principale fornito, il corpo di un
teorema esistenziale fornito (ma con tutte le occorrenze della variabile
legata sostituite con una variabile fornita), e aggiunge le assunzioni del
teorema esistenziale. Alla variabile fornita non &egrave; permesso di essere
libera nella conclusione del teorema esistenziale o nelle altre assuzioni del
teorema principale originario o nella sua conclusione. Si noti che il corpo
alterato del teorema esistenziale non deve essere presente nelle assunzioni
del teorema principale affinch&eacute; questa regola abbia successo.</p>
<p>See also: exists_rule, mk_exists_rule.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs5', 5)" onmouseover="showTip(event, 'fs5', 5)" class="fn">choose_rule</span>

<span class="c">//    `y`   A1 |- ?x. p    A2 |- q      [ con &quot;y&quot; non libera in:                    </span>
<span class="c">//    -----------------------------         `?x. p`, `q` o `A2\{p[y/x]}` ]   </span>
<span class="c">//        A1 u A2\{p[y/x]} |- q               </span>
</code></pre>
<h2>| Bool.conj_rule</h2>
<p>Questa &egrave; la regola di e-introduzione. Congiunge i due teoremi forniti
e unisce le loro assunzioni.</p>
<p>Si veda anche: conjunct1_rule, conjunct2_rule, mk_conj_rule.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs6', 6)" onmouseover="showTip(event, 'fs6', 6)" class="fn">conj_rule</span>

<span class="c">//   A1 |- p    A2 |- q                                                   </span>
<span class="c">//   ------------------                                                   </span>
<span class="c">//   A1 u A2 |- p /\ q </span>
</code></pre>
<h2>| Bool.conjunct1_rule</h2>
<p>Questa &egrave; la regola di e-eliminazione a sinistra. Rimuove il
congiunto a destra dal teorema di congiuzione fornito.</p>
<p>Si veda anche: conjunct2_rule, conjunct_rule, mk_conj_rule.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs7', 7)" onmouseover="showTip(event, 'fs7', 7)" class="fn">conjunct1_rule</span>

<span class="c">//   A |- p /\ q                                                             </span>
<span class="c">//   -----------                                                             </span>
<span class="c">//     A |- p   </span>
</code></pre>
<h2>| Bool.conjunct2_rule</h2>
<p>Questa &egrave; la regola di e-eliminazione a destra. Rimuove il
congiunto a sinistra dal teorema di congiuzione fornito.</p>
<p>Si veda anche: conjunct1_rule, conjunct_rule, mk_conj_rule.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs8', 8)" onmouseover="showTip(event, 'fs8', 8)" class="fn">conjunct2_rule</span>

<span class="c">//   A |- p /\ q                                                             </span>
<span class="c">//   -----------                                                             </span>
<span class="c">//     A |- q   </span>
</code></pre>
<h2>| Bool.contr_rule</h2>
<p>Questa &egrave; la regola di contraddizione della logica intuizionista. Prende
un termine booleano e un teorema con falso come conclusione. Restituisce un
teorema con il termine fornito come sua conclusione, sotto le stess assunzioni
del teorema fornito.</p>
<p>See also: ccontr_rule, deduct_contrapos_rule.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs9', 9)" onmouseover="showTip(event, 'fs9', 9)" class="fn">contr_rule</span>

<span class="c">//  `p`   A |- false                                                       </span>
<span class="c">//  ----------------                                                       </span>
<span class="c">//       A |- p        </span>
</code></pre>
<h2>| Bool.deduct_antisym_rule</h2>
<p>Questa &egrave; la regola di antisimmetria per la deduzione. Prende due
teoremi come argomenti. Restituisce un teorema che afferma che le conclusioni
fornite sono equivalente, sotto l'unione delle assunzioni ma con la conclusione
di un teorema rimossa dalle assunzioni dell'altro</p>
<p>See also: imp_antisym_rule, undisch_rule.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs10', 10)" onmouseover="showTip(event, 'fs10', 10)" class="fn">deduct_antisym_rule</span>

<span class="c">//       A1 |- p    A2 |- q      </span>
<span class="c">//   --------------------------              </span>
<span class="c">//   A1\{q} u A2\{p} |- p &lt;=&gt; q   </span>
</code></pre>
<h2>| Bool.deduct_contrapos_rule</h2>
<p>Questa &egrave; la regola di contraddizione per la deduzione. Scambia e
nega logicamente il termine dell'assunzione fornita e la conclusione del
teorema fornito. Si noti che il termine fornito non deve essere presente
nelle assunzioni del teorema di input perhc&eacute; la regola abbia successo.
Se la negazione logica della conclusione del teorema in input coincide con
il termine fornito, allora non occorrer&agrave; nelle assunzioni del teorema
risultante.</p>
<p>See also: not_intro_rule, disch_rule, contr_rule, ccontr_rule.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs11', 11)" onmouseover="showTip(event, 'fs11', 11)" class="fn">deduct_contrapos_rule</span>

<span class="c">//       `q`   A |- p                                                     </span>
<span class="c">//   ---------------------                                                </span>
<span class="c">//   (A u {~p})\{q} |- ~ q      </span>
</code></pre>
<h2>| Bool.disj1_rule</h2>
<p>Questa &egrave; la regola di o-introduzione per il lato sinistro. Disgiunge il
termine booleano fornito al lato destro del teorema in input.</p>
<p>Si veda anche: disj2_rule, disj_cases_rule, mk_disj1_rule.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs12', 12)" onmouseover="showTip(event, 'fs12', 12)" class="fn">disj1_rule</span>

<span class="c">//    A |- p   `q`</span>
<span class="c">//    ------------</span>
<span class="c">//    A |- p \/ q</span>
</code></pre>
<h2>| Bool.disj2_rule</h2>
<p>Questa &egrave; la regola di o-introduzione per il lato destro. Disgiunge il
termine booleano fornito al lato sinistro del teorema in input.</p>
<p>Si veda anche: disj2_rule, disj_cases_rule, mk_disj1_rule.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs13', 13)" onmouseover="showTip(event, 'fs13', 13)" class="fn">disj2_rule</span>

<span class="c">//   `p`   A |- q                                                           </span>
<span class="c">//   ------------                                                           </span>
<span class="c">//   A |- p \/ q      </span>
</code></pre>
<h2>| Bool.disj_cases_rule</h2>
<p>Questa &egrave; la regola di o-eliminazione. Prende un teorema di disgiunzione
e due teoremi extra che condividono la stessa conclusione. Restituisce un
teorema con la stessa conclusione dei teoremi extra. Le assunzioni del teorema
restituito sono l'unione delle assunzioni dei teoremi extra, ma con il
lato sinistro del teorema di disgiunzione rimosso dalle assunzioni del primo
e il lato destro rimosso da quelle del secondo, e unite insieme con le
assunzioni del teorema di disgiunzione.</p>
<p>Si veda anche: disj1_rule, disj2_rule, mk_disj_rule.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs14', 14)" onmouseover="showTip(event, 'fs14', 14)" class="fn">disj_cases_rule</span>

<span class="c">//  A |- p \/ q    A1 |- r    A2 |- r                                       </span>
<span class="c">//  ---------------------------------                                       </span>
<span class="c">//      A u A1\{p} u A2\{q} |- r     </span>
</code></pre>
<h2>| Bool.eq_imp_rule1</h2>
<p>Questa &egrave; la prima regola di eliminazione dell'equivalenza.
Prende un teorema che afferma l'equivalenza di due termini booleani, e
restituisce un teorema che afferna che il sinistro implica il destro,
sotto le stesse assunzioni.</p>
<p>Si veda anche: eq_imp_rule2, imp_antisym_rule, eq_mp_rule, undisch_rule, mk_imp_rule.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs15', 15)" onmouseover="showTip(event, 'fs15', 15)" class="fn">eq_imp_rule1</span>

<span class="c">// A |- p &lt;=&gt; q</span>
<span class="c">// ------------</span>
<span class="c">// A |- p ==&gt; q</span>
</code></pre>
<h2>| Bool.eq_imp_rule2</h2>
<p>Questa &egrave; la seconda regola di eliminazione dell'equivalenza.
Prende un teorema che afferma l'equivalenza di due termini booleani, e
restituisce un teorema che afferna che il destro implica il sinistro,
sotto le stesse assunzioni.</p>
<p>Si veda anche: eq_imp_rule1, imp_antisym_rule, eq_mp_rule, undisch_rule, mk_imp_rule.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs16', 16)" onmouseover="showTip(event, 'fs16', 16)" class="fn">eq_imp_rule2</span>

<span class="c">// A |- p &lt;=&gt; q</span>
<span class="c">// ------------</span>
<span class="c">// A |- q ==&gt; p</span>
</code></pre>
<h2>| Bool.eqf_elim_rule</h2>
<p>Questa &egrave; la regola di eliminazione di equivalenza a falso. Prende un
teoram di equivalenza con la <code>false</code> sulla destra, e restituisce la negazione
logica del lato sinistro, sotto le stesse assunzioni.</p>
<p>Si veda anche: eqf_intro_rule, not_intro_rule, not_elim_rule, mk_not_rule,
eqt_elim_rule, deduct_contrapos_rule.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs17', 17)" onmouseover="showTip(event, 'fs17', 17)" class="fn">eqf_elim_rule</span>

<span class="c">//  A |- p &lt;=&gt; false                                                     </span>
<span class="c">//  ----------------                                                     </span>
<span class="c">//      A |- ~ p       </span>
</code></pre>
<h2>| Bool.eqf_intro_rule</h2>
<p>Questa &egrave; la regola di introduzione di equivalenza a falso. Prende un
teoram con la negazione logica come sua conclusione, e restituisce un teoram
che afferma che il corpo della negazione &egrave; equivalente a <code>false</code>, sotto
le stesse assunzioni.</p>
<p>Si veda anche: eqf_elim_rule, not_elim_rule, not_intro_rule, mk_not_rule,
eqt_intro_rule.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs18', 18)" onmouseover="showTip(event, 'fs18', 18)" class="fn">eqf_intro_rule</span>

<span class="c">//      A |- ~ p                                                           </span>
<span class="c">//  ----------------                                                       </span>
<span class="c">//  A |- p &lt;=&gt; false   </span>
</code></pre>
<h2>| Bool.eqt_elim_rule</h2>
<p>Questa &egrave; la regola di eliminazione di equivalenza a vero. Prende un
teoram di guguaglianza con ha <code>true</code> sul lato destro, e restituisce un
teorema che afferma che il lato sinistro vale, sotto le stesse assunzioni.</p>
<p>Si veda anche: eqt_intro_rule, eqf_elim_rule.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs19', 19)" onmouseover="showTip(event, 'fs19', 19)" class="fn">eqt_elim_rule</span>

<span class="c">//  A |- p &lt;=&gt; true                                                       </span>
<span class="c">//  ---------------                                                       </span>
<span class="c">//      A |- p       </span>
</code></pre>
<h2>| Bool.eqt_intro_rule</h2>
<p>Questa &egrave; la regola di introduzione di equivalenza a vero. Prende un
qualsiasi teorema, e restituisce il teorema che afferma che la conclusione
&egrave; equivalente a <code>true</code>, sotto le stesse assunzioni.</p>
<p>Si veda anche: eqt_elim_rule, eq\f_intro_rule.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs20', 20)" onmouseover="showTip(event, 'fs20', 20)" class="fn">eqt_intro_rule</span>

<span class="c">//       A |- p                                                         </span>
<span class="c">//  ---------------                                                     </span>
<span class="c">//  A |- p &lt;=&gt; true      </span>
</code></pre>
<h2>| Bool.eta_conv</h2>
<p>Questa &egrave; la regola di eta riduzione. Prende un termine di lambda
astrazione, dove il corpo &egrave; un'applicazione di funzione, e la variabile
legata &egrave; il sottotermine argomento dell'applicazione della funzione e
non &egrave; libera nel sottotermine funzione. Restituisce un teoream che
afferma che il termine &egrave; uguale al sottotermine funzione, senza alcuna
assunzione.</p>
<p>Si veda anche: beta_conv.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs21', 21)" onmouseover="showTip(event, 'fs21', 21)" class="fn">eta_conv</span>

<span class="c">//     `\x. f x`                                                           </span>
<span class="c">//  ----------------                                                       </span>
<span class="c">//  |- (\x. f x) = f   </span>
</code></pre>
<h2>| NatEval.eta_conv</h2>
<p>Questa &egrave; la conversione di valutazione per l'addizione numerale. Prende
un termine della forma <code>m + n</code>, dove <code>m</code> e <code>n</code> sono entrambi numeri naturali,
e restituisce un teorema che afferma che questo equivale al suo valore numerale,
senza assunzioni.</p>
<p>Si veda anche: eval_sub_conv, eval_mult_conv, eval_exp_conv.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs22', 22)" onmouseover="showTip(event, 'fs22', 22)" class="fn">eval_add_conv</span>

<span class="c">///    `m + n`                                                             </span>
<span class="c">/// ------------                                                           </span>
<span class="c">/// |- m + n = z </span>
</code></pre>
<h2>| NatEval.eval_even_conv</h2>
<p>Questa &egrave; la conversione di valutazione per la parit&agrave; per un numerale.
Prende un termine della forma <code>Even n</code>, dove <code>n</code> &egrave; un numerale per un numero
naturale, e restituisce un teorema che afferma il suo valore booleano,
senza assunzioni.</p>
<p>Si veda anche: eval_odd_conv.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs23', 23)" onmouseover="showTip(event, 'fs23', 23)" class="fn">eval_even_conv</span>

<span class="c">//     `EVEN n`                                                         </span>
<span class="c">// ---------------                                                      </span>
<span class="c">// |- EVEN n &lt;=&gt; z    </span>
</code></pre>
<h2>| NatEval.eval_even_conv</h2>
<p>Questa &egrave; la conversione di valutazione per l'esponenziazione numerale.
Prende un termine della forma <code>m EXP n</code>, dove <code>m</code> e <code>n</code>sono entrambi numerali
di numeri naturali, e restituisce un teorema che afferma che questo equivale
al suo valore, senza assunzioni.</p>
<p>Si veda anche: eval_add_conv, eval_sub_conv, eval_mult_conv.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs24', 24)" onmouseover="showTip(event, 'fs24', 24)" class="fn">eval_exp_conv</span>

<span class="c">//    `m EXP n`                                                          </span>
<span class="c">// --------------                                                        </span>
<span class="c">// |- m EXP n = z    </span>
</code></pre>
<h2>| NatEval.eval_ge_conv</h2>
<p>Questa &egrave; la conversione di valutazione il confronto maggiore-o-uguale-a.
Prende un termine della forma <code>m &gt;= n</code>, dove <code>m</code> e <code>n</code>sono entrambi numerali
di numeri naturali, e restituisce un teorema che afferma che questo equivale
al suo valore booleano, senza assunzioni.</p>
<p>Si veda anche: eval_gt_conv, eval_le_conv, eval_lt_conv, eval_nat_eq_conv.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs25', 25)" onmouseover="showTip(event, 'fs25', 25)" class="fn">eval_ge_conv</span>

<span class="c">//      `m &gt;= n`</span>
<span class="c">//  ---------------</span>
<span class="c">//  |- m &gt;= n &lt;=&gt; z</span>
</code></pre>
<h2>| NatEval.eval_gt_conv</h2>
<p>Questa &egrave; la conversione di valutazione il confronto maggiore-di.
Prende un termine della forma <code>m &gt; n</code>, dove <code>m</code> e <code>n</code>sono entrambi numerali
di numeri naturali, e restituisce un teorema che afferma che questo equivale
al suo valore booleano, senza assunzioni.</p>
<p>Si veda anche: eval_ge_conv, eval_le_conv, eval_lt_conv, eval_nat_eq_conv.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs26', 26)" onmouseover="showTip(event, 'fs26', 26)" class="fn">eval_gt_conv</span>

<span class="c">//      `m &gt; n`    </span>
<span class="c">//  -------------- </span>
<span class="c">//  |- m &gt; n &lt;=&gt; z </span>
</code></pre>
<h2>| NatEval.eval_le_conv</h2>
<p>Questa &egrave; la conversione di valutazione per il confronto minore-o-uguale-a.
Prende un termine della forma <code>m &lt;= n</code>, dove <code>m</code> e <code>n</code>sono entrambi numerali
di numeri naturali, e restituisce un teorema che afferma che questo equivale
al suo valore booleano, senza assunzioni.</p>
<p>Si veda anche: eval_lt_conv, eval_ge_conv, eval_gt_conv, eval_nat_eq_conv.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs27', 27)" onmouseover="showTip(event, 'fs27', 27)" class="fn">eval_le_conv</span>

<span class="c">//        `m &lt;= n`                               </span>
<span class="c">//    --------------                            </span>
<span class="c">//    |- m &lt;= n &lt;=&gt; z</span>
</code></pre>
<h2>| NatEval.eval_le_conv</h2>
<p>Questa &egrave; la conversione di valutazione per il confronto minore-di.
Prende un termine della forma <code>m &lt; n</code>, dove <code>m</code> e <code>n</code>sono entrambi numerali
di numeri naturali, e restituisce un teorema che afferma che questo equivale
al suo valore booleano, senza assunzioni.</p>
<p>Si veda anche: eval_le_conv, eval_ge_conv, eval_gt_conv, eval_nat_eq_conv.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs28', 28)" onmouseover="showTip(event, 'fs28', 28)" class="fn">eval_lt_conv</span>

<span class="c">//        `m &lt; n`                               </span>
<span class="c">//    --------------                            </span>
<span class="c">//    |- m &lt; n &lt;=&gt; z</span>
</code></pre>
<p>Es.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="s">&quot;12 &lt; 7&quot;</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs29', 29)" onmouseover="showTip(event, 'fs29', 29)" class="fn">parse_term</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs28', 30)" onmouseover="showTip(event, 'fs28', 30)" class="fn">eval_lt_conv</span>
<span class="c">// val it : thm = |- 12 &lt; 7 &lt;=&gt; false</span>

<span class="s">&quot;7 &lt; 12&quot;</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs29', 31)" onmouseover="showTip(event, 'fs29', 31)" class="fn">parse_term</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs28', 32)" onmouseover="showTip(event, 'fs28', 32)" class="fn">eval_lt_conv</span>
<span class="c">// val it : thm = |- 7 &lt; 12 &lt;=&gt; true</span>
</code></pre>
<h2>| NatEval.eval_mult_conv</h2>
<p>Questa &egrave; la conversione di valutazione per la moltiplicazione numerale.
Prende un termine della forma <code>m * n</code>, dove <code>m</code> e <code>n</code> sono entrambi numerali di
numeri naturali, e restituisce un teorema che afferma che questo equivale al
suo valore numerale, senza assunzioni.</p>
<p>Si veda anche: eval_add_conv, eval_sub_conv, eval_exp_conv.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs30', 33)" onmouseover="showTip(event, 'fs30', 33)" class="fn">eval_mult_conv</span>

<span class="c">//     `m * n`                                                            </span>
<span class="c">//  ------------                                                          </span>
<span class="c">//  |- m * n = z</span>
</code></pre>
<p>Es.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span class="s">&quot;12 * 7&quot;</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs29', 34)" onmouseover="showTip(event, 'fs29', 34)" class="fn">parse_term</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, 'fs30', 35)" onmouseover="showTip(event, 'fs30', 35)" class="fn">eval_mult_conv</span>
<span class="c">// val it : thm = |- 12 * 7 = 84</span>
</code></pre>
<h2>| NatEval.eval_nat_eq_conv</h2>
<p>Questa &egrave; la conversione di valutazione per l'eguaglianza numerica.
Prende un termine della forma <code>m = n</code>, dove <code>m</code> e <code>n</code> sono entrambi numerali di
numeri naturali, e restituisce un teorema che afferma che questo equivale al
suo valore booleano, senza assunzioni.</p>
<p>Si veda anche: eval_le_conv, eval_lt_conv, eval_ge_conv, eval_gt_conv.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs31', 36)" onmouseover="showTip(event, 'fs31', 36)" class="fn">eval_nat_eq_conv</span>

<span class="c">//      `m = n`                                                            </span>
<span class="c">//  --------------                                                         </span>
<span class="c">//  |- m = n &lt;=&gt; z   </span>
</code></pre>
<h2>| NatEval.eval_odd_conv</h2>
<p>Questa &egrave; la conversione di valutazione per la disparit&agrave; numerale.
Prende un termine della forma <code>ODD n</code>, dove <code>n</code> &egrave; un numerale di un numero
naturale, e restituisce un teorema che afferma il suo valore booleano, senza
assunzioni.</p>
<p>Si veda anche: eval_even_conv.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs32', 37)" onmouseover="showTip(event, 'fs32', 37)" class="fn">eval_odd_conv</span>

<span class="c">//      `ODD n`                                                            </span>
<span class="c">//  --------------                                                         </span>
<span class="c">//  |- ODD n &lt;=&gt; z </span>
</code></pre>
<h2>| NatEval.eval_pre_conv</h2>
<p>Questa &egrave; la conversione di valutazione per il predcessore numerale. Prende
un termine della forma <code>PRE n</code>, dove <code>n</code> &amp;egrave, un numerale di un numero naturale,
e restituisce un teorema che afferma che questo equivale al suo valore numerale,
senza assunzioni.</p>
<p>Si veda anche: eval_suc_conv.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs33', 38)" onmouseover="showTip(event, 'fs33', 38)" class="fn">eval_pre_conv</span>

<span class="c">//     `PRE n`                                                         </span>
<span class="c">//  ------------                                                       </span>
<span class="c">//  |- PRE n = z   </span>
</code></pre>
<h2>| NatEval.eval_sub_conv</h2>
<p>Questa &egrave; la conversione di valutazione per la sottrazione numerale. Prende
un termine della forma <code>m - n</code>, dove <code>m</code> e <code>n</code> sono entrambi numerali di numeri
naturali, e restituisce un teorema che afferma che questo equivale al suo
valore numerale, senza assunzioni.</p>
<p>Si veda anche: eval_add_conv, eval_mult_conv, eval_exp_conv.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs34', 39)" onmouseover="showTip(event, 'fs34', 39)" class="fn">eval_sub_conv</span>

<span class="c">//     `m - n`                                                         </span>
<span class="c">//  ------------                                                       </span>
<span class="c">//  |- m - n = z  </span>
</code></pre>
<h2>| NatEval.eval_sub_conv</h2>
<p>Questa &egrave; la conversione di valutazione per il successore numerale. Prende
un termine della forma <code>SUCC n</code>, dove <code>n</code> &egrave; un numerale per un numero naturale,
e restituisce un teorema che afferma che questo equivale al suo valore numerale,
senza assunzioni.</p>
<p>Si veda anche: eval_add_conv, eval_mult_conv, eval_exp_conv.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs35', 40)" onmouseover="showTip(event, 'fs35', 40)" class="fn">eval_suc_conv</span>

<span class="c">//     `SUC n`                                                            </span>
<span class="c">//  ------------                                                          </span>
<span class="c">//  |- SUC n = z     </span>
</code></pre>
<h2>| BoolClass.eval_sub_conv</h2>
<p>Questa &egrave; di introduzione del quantificatore esistenziale. Prende
un termine esistenziale, un termine testimone, e un teorema, dove la conclusione
del teorea &egrave; il corpo del termine esistenziale ma con il termine testimone
che sostituisce le occorrenze della sua variabile legata. Restituisce un teorema
che afferma che il termine esistenziale fornito vale, sotto le stesse
assunzioni del teorema fornito.</p>
<p>Si veda anche: choose_rule, select_rule, mk_exists_rule.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs36', 41)" onmouseover="showTip(event, 'fs36', 41)" class="fn">exists_rule</span>

<span class="c">//  `?x. p`   `t`   A |- p[t/x]                                            </span>
<span class="c">//  ---------------------------                                            </span>
<span class="c">//          A |- ?x. p    </span>
</code></pre>
<h2>| Bool.gen_rule</h2>
<p>Questa &egrave; di introduzione del quantificatore universale. Quantifica
universamente il teorema fornito con la variabile legata fornita sotto le
stesse assunzioni. La variabile legata non deve comparire libera nelle
assunzioni.</p>
<p>Si veda anche: list_gen_rule, spec_rule, mk_forall_rule.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs37', 42)" onmouseover="showTip(event, 'fs37', 42)" class="fn">gen_rule</span>

<span class="c">// `x`   A |- p         [ &quot;x&quot; not free in `A` ]                           </span>
<span class="c">// ------------                                                           </span>
<span class="c">//  A |- !x. p        </span>
</code></pre>
<h2>| Bool.imp_antisym_rule</h2>
<p>Questa &egrave; la regola di antisimmetria per l'implicazione. Prende due
teoremi di implicazione come argomenti, dove il lato sinistro di ciascuno
&egrave; lo stesso (modulo alfa-equivalenza) del lato destro dell'altro.
Restituisce</p>
<p>Si veda anche: list_gen_rule, spec_rule, mk_forall_rule.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs38', 43)" onmouseover="showTip(event, 'fs38', 43)" class="fn">imp_antisym_rule</span>

<span class="c">//   A1 |- p ==&gt; q    A2 |- q ==&gt; p                                       </span>
<span class="c">//   ------------------------------                                       </span>
<span class="c">//         A1 u A2 |- p &lt;=&gt; q   </span>
</code></pre>
<h2>| Bool.imp_trans_rule</h2>
<p>Questa &egrave; la regola di transitivt&agrave; per l'implicazione. Prende due
teoremi d'implicazione come argomenti, dove il lato destro del primo teorema
&egrave; lo stesso (modulo alfa-equivalenza) del lato sinistro del secondo.
Restituisce un teorema che afferma che il lato sinistro del primo teorema
implica il lato destro del secondo, sotto l'unione delle assunzione dei due
teoremi.</p>
<p>Si veda anche: list_imp_trans_rule, eq_trans_rule, disch_rule, imp_anitsym_asm_rule.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs39', 44)" onmouseover="showTip(event, 'fs39', 44)" class="fn">imp_trans_rule</span>

<span class="c">//  A1 |- p ==&gt; q    A2 |- q ==&gt; r                                        </span>
<span class="c">//  ------------------------------                                        </span>
<span class="c">//        A1 u A2 |- p ==&gt; r        </span>
</code></pre>
<h2>| Bool.inst_rule</h2>
<p>...</p>
<p>Si veda anche: gen<em>rule, list</em>spec_rule.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs40', 45)" onmouseover="showTip(event, 'fs40', 45)" class="fn">list_gen_rule</span>
</code></pre>
<h2>| Bool.list_imp_trans_rule</h2>
<p>...</p>
<p>Si veda anche: imp_trans_rule.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs41', 46)" onmouseover="showTip(event, 'fs41', 46)" class="fn">list_imp_trans_rule</span>
</code></pre>
<h2>| Bool.list_spec_rule</h2>
<p>Questa &egrave; la regola di eliminazine universale composta. Spoglia il
quantificatore universale pi&ugrave; esterno del teorema fornito per
ogni elemento nella lista di termini fornita, sostituendo nel corpo ciascuna
occorrenza di una variabile legata eliminata con il corrispondente elemento
nella lista di termini. Il tipo di ogni termine nella lista deve essere
uguale al tipo della sua corrispondente variabile.</p>
<p>Si veda anche: spec_rule, spec_all_rule, bspec_rule, list_gen_rule.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs42', 47)" onmouseover="showTip(event, 'fs42', 47)" class="fn">list_spec_rule</span>

<span class="c">//  [`t1`;`t2`;..]   A |- !x1 x2 .. . p                                   </span>
<span class="c">//  -----------------------------------                                   </span>
<span class="c">//         A |- p[t1/x1;t2/x2;..]    </span>
</code></pre>
<h2>| EqCong.mk_bin_rule</h2>
<p>Questa &egrave; la regola di congruenza di eguaglianza per l'applicazione di
funzione binaria. Prende un termine di funzione binaria e due teoremi di
eguaglianza, e applica la funzione nella forma curried ai corrispondenti
lati di ciascun teorema, sotto l'unione delle loro assunzioni. Il tipo
della funzione fornita deve avere essere binario nella forma curried, con i tipi
del primo e del secondo dominio uguali al tipo di ciascun lato del teorema
corrispondente.</p>
<p>Si veda anche: mk_comb_rule.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs43', 48)" onmouseover="showTip(event, 'fs43', 48)" class="fn">mk_bin_rule</span>

<span class="c">//  `f`   A1 |- s1 = s2    A2 |- t1 = t2                                  </span>
<span class="c">//  ------------------------------------                                  </span>
<span class="c">//      A1 u A2 |- f s1 t1 = f s2 t2    </span>
</code></pre>
<h2>| EqCong.mk_bin1_rule</h2>
<p>Questa &egrave; la regola di congruenza di eguaglianza per l'applicazione di
funzione binaria sul lato sinistro. Prende un termine di funzione binaria, un
teorema di uguaglianza e un termine, e applica la funzione in forma curried
ai lati corrispondenti del teorema come suo lato sinistro e il termine fornito
come lato destro. Il tipo della funzione fornita deve avere essere binario
nella forma curried, con il tipo del primo dominio uguale al tipo di ciascun
lato del teorema e il secondo dominio uguale al tipo del termine argomento
aggiunto a destra.</p>
<p>Si veda anche: mk_bin2_rule, mk_bin_rule, mk_comb_rule.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs44', 49)" onmouseover="showTip(event, 'fs44', 49)" class="fn">mk_bin1_rule</span>

<span class="c">//  `f`   |- s1 = s2   `t`                                                </span>
<span class="c">//  ----------------------                                                </span>
<span class="c">//    |- f s1 t = f s2 t         </span>
</code></pre>
<h2>| EqCong.mk_bin2_rule</h2>
<p>Questa &egrave; la regola di congruenza di eguaglianza per l'applicazione di
funzione binaria sul lato destro. Prende un termine di funzione binaria, un
teorema di uguaglianza e un termine, e applica la funzione in forma curried
al termine fornito sul lato sinistro e ai lati corrispondenti del teorema
come suo lato destro. Il tipo della funzione fornita deve avere essere binario
nella forma curried, con il tipo del primo dominio uguale al tipo del termine
argomento a sinistra, e il tipo del secondo dominio uguale al tipo di ciascun
lato del teorema.</p>
<p>Si veda anche: mk_bin1_rule, mk_bin_rule, mk_comb_rule.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs45', 50)" onmouseover="showTip(event, 'fs45', 50)" class="fn">mk_bin2_rule</span>

<span class="c">// `f`   `s`   |- t1 = t2                                                 </span>
<span class="c">// ----------------------                                                 </span>
<span class="c">//   |- f s t1 = f s t2   </span>
</code></pre>
<h2>| EqCong.mk_conj_rule</h2>
<p>Questa &egrave; la regola di congruenza per la congiunzione. Prende due teoremi
di egualianza boolena, e congiunge i corrispondenti lati del rpimo teorema
con quelli del secondo, unendone le assunzioni.</p>
<p>Si veda anche: mk_conj1_rule, mk_conj2_rule, mk_bin_rule, conj_rule.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs46', 51)" onmouseover="showTip(event, 'fs46', 51)" class="fn">mk_conj_rule</span>

<span class="c">//  A1 |- p1 &lt;=&gt; p2    A2 |- q1 &lt;=&gt; q2                                   </span>
<span class="c">//  ----------------------------------                                   </span>
<span class="c">//   A1 u A2 |- p1 /\ q1 &lt;=&gt; p2 /\ q2  </span>
</code></pre>
<h2>| EqCong.mk_conj1_rule</h2>
<p>Questa &egrave; la regola di congruenza per il lato sinistro della congiunzione.
Prende un teorema di eguaglianza booleana e un termine booleano, e congiunge
ciaszun lato del teorema con il termine fornito</p>
<p>Si veda anche: mk_conj2_rule, mk_conj_rule, mk_bin1_rule, conj_rule.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs47', 52)" onmouseover="showTip(event, 'fs47', 52)" class="fn">mk_conj1_rule</span>

<span class="c">//    A |- p1 &lt;=&gt; p2   `q`                                                 </span>
<span class="c">//  ------------------------                                               </span>
<span class="c">//  A |- p1 /\ q &lt;=&gt; p2 /\ q     </span>
</code></pre>
<h2>| EqCong.mk_conj1_rule</h2>
<p>Questa &egrave; la regola di congruenza per il lato destro della congiunzione.
Prende un termine booleano e un teorema di eguaglianza booleana, e congiunge il
termine fornito con ciascun lato del teorema.</p>
<p>Si veda anche: mk_conj1_rule, mk_conj_rule, mk_bin1_rule, conj_rule.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs48', 53)" onmouseover="showTip(event, 'fs48', 53)" class="fn">mk_conj2_rule</span>

<span class="c">//    `p`   A |- q1 &lt;=&gt; q2                                             </span>
<span class="c">//  ------------------------                                           </span>
<span class="c">//  A |- p /\ q1 &lt;=&gt; p /\ q2   </span>
</code></pre>
<h2>| EqCong.mk_disj_rule</h2>
<p>Questa &egrave; la regola di congruenza per la disgiunzione, Prende due
teoremi di eguaglianza booleana, e disgiunge i corrispondenti lati del
primo teorema con quelli del secondo, unendone le assunzioni.</p>
<p>Si veda anche: mk_disj1_rule, mk_disj2_rule, mk_bin_rule, disj1_rule, disj2_rule.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs49', 54)" onmouseover="showTip(event, 'fs49', 54)" class="fn">mk_disj_rule</span>

<span class="c">//  A1 |- p1 &lt;=&gt; p2    A2 |- q1 &lt;=&gt; q2                                   </span>
<span class="c">//  ----------------------------------                                   </span>
<span class="c">//   A1 u A2 |- p1 \/ q1 &lt;=&gt; p2 \/ q2    </span>
</code></pre>
<h2>| EqCong.mk_disj1_rule</h2>
<p>Questa &egrave; la regola di congruenza dell'eguaglianza per la disgiunzione sul
lato sinistro. Prende un teorema di eguaglianza booleana e un termine booleano,
e disgiunge ogni lato del teorema con il termine fornito.</p>
<p>Si veda anche: mk_disj2_rule, mk_disj_rule, mk_bin1_rule, disj1_rule.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs50', 55)" onmouseover="showTip(event, 'fs50', 55)" class="fn">mk_disj1_rule</span>

<span class="c">//     A |- p1 &lt;=&gt; p2   `q`                                                 </span>
<span class="c">//   ------------------------                                               </span>
<span class="c">//   A |- p1 \/ q &lt;=&gt; p2 \/ q  </span>
</code></pre>
<h2>| EqCong.mk_disj2_rule</h2>
<p>Questa &egrave; la regola di congruenza dell'eguaglianza per la disgiunzione sul
lato destro. Prende un termine booleano e un teorema di eguaglianza booleana,
e disgiunge il termine fornito con ogni lato del teorema.</p>
<p>Si veda anche: mk_disj1_rule, mk_disj_rule, mk_bin1_rule, disj2_rule.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs51', 56)" onmouseover="showTip(event, 'fs51', 56)" class="fn">mk_disj2_rule</span>

<span class="c">//    `p`   A |- q1 &lt;=&gt; q2                                             </span>
<span class="c">//  ------------------------                                           </span>
<span class="c">//  A |- p \/ q1 &lt;=&gt; p \/ q2   </span>
</code></pre>
<h2>| EqCong.mk_eq_rule</h2>
<p>Questa &egrave; la regola di congruenza dell'eguaglianza per l'eguaglianza.
Prende due teoremi di uguaglianza, e uguaglia i corrispondenti lati del
primo teorema con quelli del secondo, unendone le assunzioni. I tipi di
ciascun lato di ogni equazione devono essere uguali.</p>
<p>Si veda anche: mk_eq1_rule, mk_eq2_rule, mk_eq_rule.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs52', 57)" onmouseover="showTip(event, 'fs52', 57)" class="fn">mk_eq_rule</span>

<span class="c">//  A1 |- s1 = s2    A2 |- t1 = t2                                          </span>
<span class="c">//  ------------------------------                                          </span>
<span class="c">//  A1 u A2 |- s1 = t1 &lt;=&gt; s2 = t2  </span>
</code></pre>
<h2>| EqCong.mk_eq1_rule</h2>
<p>Questa &egrave; la regola di congruenza dell'eguaglianza per l'eguaglianza
sul lato sinistro. Prende un teorema di uguaglianza e un termine, e uguaglia
ogni lato del teorema con il termine fornito. Il tipo del termine fornito
deve essere uguale al tipo di ciascun lato del teorema fornito.</p>
<p>Si veda anche: mk_eq2_rule, mk_eq_rule, mk_eq1_rule.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs53', 58)" onmouseover="showTip(event, 'fs53', 58)" class="fn">mk_eq1_rule</span>

<span class="c">//   A |- s1 = s2   `t`                                                   </span>
<span class="c">// ----------------------                                                 </span>
<span class="c">// A |- s1 = t &lt;=&gt; s2 = t  </span>
</code></pre>
<h2>| EqCong.mk_eq2_rule</h2>
<p>Questa &egrave; la regola di congruenza dell'eguaglianza per l'eguaglianza
sul lato destro. Prende un termine e un teorema di eguaglianza, e uguaglia
il termine a ciascun lato del teorema. Il tipo del termine fornito deve
essere uguale al tipo di cascun lato del teorema fornito.</p>
<p>Si veda anche: mk_eq1_rule, mk_eq_rule, mk_eq1_rule.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs54', 59)" onmouseover="showTip(event, 'fs54', 59)" class="fn">mk_eq2_rule</span>

<span class="c">//    `s`   A |- t1 = t2                                                   </span>
<span class="c">//  ----------------------                                                 </span>
<span class="c">//  A |- s = t1 &lt;=&gt; s = t2    </span>
</code></pre>
<h2>| EqCong.mk_exists_rule</h2>
<p>Questa &egrave; la regola di congruenza dell'eguaglianza per la quantificazione
esistenziale. Prende una variabile e un teorema di uguaglianza, e quantifica
in modo esistenzaiale la variabile su entrambi i lati del teorema. La variabile
non deve occorrere libera nelle assunzioni del teorema fornito</p>
<p>Si veda anche: mk_uexists_rule, mk_abs_rule, mk_comb_rule, exists_rule.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs55', 60)" onmouseover="showTip(event, 'fs55', 60)" class="fn">mk_exists_rule</span>

<span class="c">//     `x`   A |- p1 &lt;=&gt; p2         [ &quot;x&quot; not free in `A` ]                </span>
<span class="c">//  --------------------------                                             </span>
<span class="c">//  A |- (?x. p1) &lt;=&gt; (?x. p2)  </span>
</code></pre>
<h2>| EqCong.mk_forall_rule</h2>
<p>Questa &egrave; la regola di congruenza dell'eguaglianza per la quantificazione
universale. Prende una variabile e un teorema di uguaglianza, e quantifica
universalmente la variabile su entrambi i lati del teorema. La variabile
non deve occorrere libera nelle assunzioni del teorema fornito</p>
<p>Si veda anche: mk_abs_rule, mk_comb_rule, gen_rule.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs56', 61)" onmouseover="showTip(event, 'fs56', 61)" class="fn">mk_forall_rule</span>

<span class="c">//     `x`   A |- p1 &lt;=&gt; p2         [ &quot;x&quot; not free in `A` ]              </span>
<span class="c">//  --------------------------                                           </span>
<span class="c">//  A |- (!x. p1) &lt;=&gt; (!x. p2)    </span>
</code></pre>
<h2>| EqCong.mk_imp_rule</h2>
<p>Questa &egrave; la regola di congruenza dell'eguaglianza per l'implicazione.
Prende due teoremi di eguaglianza booleana, e crea l'implicazione dai
corrispondeti lati del primo e del secondo teorema, unendone le assunzioni.</p>
<p>Si veda anche: mk_imp1_rule, mk_imp2_rule, mk_bin_rule.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs57', 62)" onmouseover="showTip(event, 'fs57', 62)" class="fn">mk_imp_rule</span>

<span class="c">//  A1 |- p1 &lt;=&gt; p2    A2 |- q1 &lt;=&gt; q2                                    </span>
<span class="c">//  ----------------------------------                                    </span>
<span class="c">//  A1 u A2 |- p1 ==&gt; q1 &lt;=&gt; p2 ==&gt; q2 </span>
</code></pre>
<h2>| EqCong.mk_imp1_rule</h2>
<p>Questa &egrave; la regola di congruenza dell'eguaglianza per l'implicazione
su lato sinistro. Prende un teorema di eguaglianza booleana e un termine
booleano, e crea le implicazioni da ogni lato del teorema, con il lato
del teorema come antecedente e il termine come conseguente.</p>
<p>Si veda anche: mk_imp2_rule, mk_imp_rule, mk_bin1_rule</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs58', 63)" onmouseover="showTip(event, 'fs58', 63)" class="fn">mk_imp1_rule</span>

<span class="c">//    A |- p1 &lt;=&gt; p2   `q`                                               </span>
<span class="c">// --------------------------                                            </span>
<span class="c">// A |- p1 ==&gt; q &lt;=&gt; p2 ==&gt; q    </span>
</code></pre>
<h2>| EqCong.mk_imp2_rule</h2>
<p>Questa &egrave; la regola di congruenza dell'eguaglianza per l'implicazione
su lato destro. Prende un termine booleano e un teorema di eguaglianza
booleana, e rende il termine un antecedente di ciascun lato del teorema.</p>
<p>Si veda anche: mk_imp1_rule, mk_imp_rule, mk_bin2_rule</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs59', 64)" onmouseover="showTip(event, 'fs59', 64)" class="fn">mk_imp2_rule</span>

<span class="c">//    `p`   A |- q1 &lt;=&gt; q2                                            </span>
<span class="c">//  --------------------------                                        </span>
<span class="c">//  A |- p ==&gt; q1 &lt;=&gt; p ==&gt; q2  </span>
</code></pre>
<h2>| EqCong.mk_not_rule</h2>
<p>Questa &egrave; la regola di congruenza dell'eguaglianza per la negazione
logica, Prende un teorema di eguaglianza booleana, e nega logicamente
ciascun lato del teorema.</p>
<p>Si veda anche: mk_comb_rule, eqf_intro_rule, eqf_elim_rule.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs60', 65)" onmouseover="showTip(event, 'fs60', 65)" class="fn">mk_not_rule</span>

<span class="c">//    A |- p1 &lt;=&gt; p2                                                      </span>
<span class="c">//  ------------------                                                    </span>
<span class="c">//  A |- ~ p1 &lt;=&gt; ~ p2   </span>
</code></pre>
<h2>| Pair.mk_pair_rule</h2>
<p>Questa &egrave; la regola di congruenza dell'eguaglianza per l'accoppiamento.
Prende due teoremi di uguaglianza, e accoppia i corrispondenti lati del
primo teorema con quelli del secondo, unendone le assunzioni</p>
<p>Si veda anche: mk_pair1_rule, mk_pair2_rule, mk_bin_rule.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs61', 66)" onmouseover="showTip(event, 'fs61', 66)" class="fn">mk_pair_rule</span>

<span class="c">//  A1 |- x1 = x2    A2 |- y1 = y2                                       </span>
<span class="c">//  ------------------------------                                       </span>
<span class="c">//   A1 u A2 |- (x1,y1) = (x2,y2)    </span>
</code></pre>
<h2>| Pair.mk_pair1_rule</h2>
<p>Questa &egrave; la regola di congruenza dell'eguaglianza per la coppia a
sinistra. Prende un teorema di uguaglianza e un termine, e accoppia ogni
lato del teorema con il termine.</p>
<p>Si veda anche: mk_pair2_rule, mk_pair_rule, mk_bin1_rule.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs62', 67)" onmouseover="showTip(event, 'fs62', 67)" class="fn">mk_pair1_rule</span>

<span class="c">//    A |- x1 = x2   `y`                                                  </span>
<span class="c">//   --------------------                                                 </span>
<span class="c">//   A |- (x1,y) = (x2,y) </span>
</code></pre>
<h2>| Pair.mk_pair2_rule</h2>
<p>Questa &egrave; la regola di congruenza dell'eguaglianza per la coppia a
destra. Prende un termine un teorema di uguaglianza, e accoppia il termine
con ogni lato del teorema.</p>
<p>Si veda anche: mk_pair1_rule, mk_pair_rule, mk_bin2_rule.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs63', 68)" onmouseover="showTip(event, 'fs63', 68)" class="fn">mk_pair2_rule</span>

<span class="c">///     `x`   A |- y1 = y2                                                    </span>
<span class="c">///    --------------------                                                   </span>
<span class="c">///    A |- (x,y1) = (x,y2)  </span>
</code></pre>
<h2>| EqCong.mk_select_rule</h2>
<p>Questa &egrave; la regola di congruenza dell'eguaglianza per la selezione.
Prende una variabile e un teorema di eguaglianza, e seleziona la variabile
da entrambi i lati del teorema. La variabile non deve occorrere libera
nelle assunzioni del teorema.</p>
<p>Si veda anche: mk_abs_rule, mk_comb_rule.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs64', 69)" onmouseover="showTip(event, 'fs64', 69)" class="fn">mk_select_rule</span>

<span class="c">//    `x`   A |- p1 &lt;=&gt; p2        [ &quot;x&quot; not free in `A` ]                </span>
<span class="c">//  ------------------------                                             </span>
<span class="c">//  A |- (@x. p1) = (@x. p2)     </span>
</code></pre>
<h2>| EqCong.mk_uexists_rule</h2>
<p>Questa &egrave; la regola di congruenza dell'eguaglianza per la quantificazione
esistenziale univoca. Prende una variabile e un teorema di eguaglianza, e
quantifica con quantificatore esistenziale univoco la variabile su
entrambi i lato del teorema. La variabile non deve occorrere libera
nelle assunzioni del teorema fornito.</p>
<p>Si veda anche: mk_exists_rule, mk_abs_rule, mk_comb_rule</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs65', 70)" onmouseover="showTip(event, 'fs65', 70)" class="fn">mk_uexists_rule</span>

<span class="c">//      `x`   A |- p1 &lt;=&gt; p2        [ &quot;x&quot; not free in `A` ]               </span>
<span class="c">//  ----------------------------                                          </span>
<span class="c">//  A |- (?!x. p1) &lt;=&gt; (?!x. p2)             </span>
</code></pre>
<h2>| Bool.not_elim_rule</h2>
<p>Questa &egrave; la regola di eliminazione della negazione logica. Prende
un teorema di negazione logica, e restituisce un'implicazione con
il termine negato sul lato sinistro e <code>false</code> sul lato destro, sotto le
stesse assunzioni.</p>
<p>Si veda anche: not_intro_rule, eqf_intro_rule, eqf_elim_rule.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs66', 71)" onmouseover="showTip(event, 'fs66', 71)" class="fn">not_elim_rule</span>

<span class="c">//      A |- ~ p                                                          </span>
<span class="c">//  ----------------                                                      </span>
<span class="c">//  A |- p ==&gt; false     </span>
</code></pre>
<h2>| Bool.not_intro_rule</h2>
<p>Questa &egrave; la regola di introduzione della negazione logica. Prende un
teorema di implicazione dove il lato destro &egrave; <code>false</code>, e restituisce la
negazione logica del lato sinistro, sotto le stesse assunzioni.</p>
<p>Si veda anche: not_elim_rule, eqf_elim_rule, eqf_intro_rule, deduct_contrapos_rule.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs67', 72)" onmouseover="showTip(event, 'fs67', 72)" class="fn">not_intro_rule</span>

<span class="c">//  A |- p ==&gt; false                                                      </span>
<span class="c">//  ----------------                                                      </span>
<span class="c">//      A |- ~ p     </span>
</code></pre>
<h2>| Bool.prove_asm_rule</h2>
<p>Questa &egrave; la regola di assunzione provata. Prende due teoremi, e
restituisce il secondo teorema ma con la conclusione del primo teorema
rimossa (se presente) dalle sue assunzioni a cui sono aggiunte le assunzioni
del primo teorema. Si noti che la conclusione del primo teorema non deve
essere nelle assunzioni del secondo affinch&egrave; questa regola abbia
successo.</p>
<p>Si veda anche: mp_rule, undisch_rule.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs68', 73)" onmouseover="showTip(event, 'fs68', 73)" class="fn">prove_asm_rule</span>

<span class="c">//  A1 |- p    A2 |- q                                                     </span>
<span class="c">//  ------------------                                                     </span>
<span class="c">//  A1 u (A2\{p}) |- q   </span>
</code></pre>
<h2>| BoolClass.select_rule</h2>
<p>Questa &egrave; la regola di selezione esistenziale. Elimina il
quantificatore esistenziale del teorema fornito, e sostituisce nel corpo
ogni occorrenza della variabile legata con l'operatore di selezione
applicato al corpo originario (con la stessa variabile legata).</p>
<p>Si veda anche: exists_rule.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs69', 74)" onmouseover="showTip(event, 'fs69', 74)" class="fn">select_rule</span>

<span class="c">//     A |- ?x. p                                                         </span>
<span class="c">//  ----------------                                                      </span>
<span class="c">//  A |- p[(@x.p)/x]   </span>
</code></pre>
<h2>| Bool.spec_all_rule</h2>
<p>Questa &egrave; la regola composta di eliminazione di default del quantificatore
universale. Elimina tutti i quantificatori universali esterni dal teorema fornito.
Si noti che il teorema fornito non deve necessariamente essere una quantificazione
universale perch&egrave; il teorema abbia successo (in  questo caso il teorema
risultante &egrave; semplicemente lo stesso del teorema fornito):</p>
<p>Si veda anche: spec_rule, list_spec_rule, bspec_rule, list_gen_rule.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs70', 75)" onmouseover="showTip(event, 'fs70', 75)" class="fn">spec_all_rule</span>

<span class="c">//  A |- !x1 x2 .. xn. p                                                  </span>
<span class="c">//  --------------------                                                  </span>
<span class="c">//         A |- p  </span>
</code></pre>
<h2>| Bool.sym_conv</h2>
<p>Questa &egrave; la conversione di simmetria per l'uguaglianza. Trasforma il
termine di ugualianza fornito scambiando il lato sinistro con il destro, senza
alcuna assunzione.</p>
<p>Si veda anche: sym_rule, refl_conv.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs71', 76)" onmouseover="showTip(event, 'fs71', 76)" class="fn">sym_conv</span>

<span class="c">//          `t1 = t2`                                                      </span>
<span class="c">//   ----------------------                                                </span>
<span class="c">//   |- t1 = t2 &lt;=&gt; t2 = t1      </span>
</code></pre>
<h2>| Bool.undisch_rule</h2>
<p>Questa &egrave; la regola di scaricamento. Prende un teorema di implicazione,
e rimuove l'antecedente dalla conclusione e lo aggiunge nelle assunzioni.</p>
<p>Si veda anche: disch_rule, mp_rule, prove_asm_rule.</p>
<pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs72', 77)" onmouseover="showTip(event, 'fs72', 77)" class="fn">undisch_rule</span>

<span class="c">//  A |- p ==&gt; q                                                           </span>
<span class="c">//  ------------                                                           </span>
<span class="c">//  A u {p} |- q   </span>
</code></pre>

          <div class="tip" id="fs1">namespace HOL</div>
<div class="tip" id="fs2">val add_asm_rule : tm:term -&gt; th:thm -&gt; thm</div>
<div class="tip" id="fs3">val bspec_rule : tm:term -&gt; th:thm -&gt; thm</div>
<div class="tip" id="fs4">val ccontr_rule : tm:term -&gt; th:thm -&gt; thm</div>
<div class="tip" id="fs5">val choose_rule : v:term * th0:thm -&gt; th:thm -&gt; thm</div>
<div class="tip" id="fs6">val conj_rule : th01:thm -&gt; th02:thm -&gt; thm</div>
<div class="tip" id="fs7">val conjunct1_rule : th:thm -&gt; thm</div>
<div class="tip" id="fs8">val conjunct2_rule : th:thm -&gt; thm</div>
<div class="tip" id="fs9">val contr_rule : tm:term -&gt; th:thm -&gt; thm</div>
<div class="tip" id="fs10">val deduct_antisym_rule : th01:thm -&gt; th02:thm -&gt; thm</div>
<div class="tip" id="fs11">val deduct_contrapos_rule : tm1:term -&gt; th:thm -&gt; thm</div>
<div class="tip" id="fs12">val disj1_rule : th:thm -&gt; tm:term -&gt; thm</div>
<div class="tip" id="fs13">val disj2_rule : tm:term -&gt; th:thm -&gt; thm</div>
<div class="tip" id="fs14">val disj_cases_rule : th0:thm -&gt; th01:thm -&gt; th02:thm -&gt; thm</div>
<div class="tip" id="fs15">val eq_imp_rule1 : th:thm -&gt; thm</div>
<div class="tip" id="fs16">val eq_imp_rule2 : th:thm -&gt; thm</div>
<div class="tip" id="fs17">val eqf_elim_rule : th:thm -&gt; thm</div>
<div class="tip" id="fs18">val eqf_intro_rule : th:thm -&gt; thm</div>
<div class="tip" id="fs19">val eqt_elim_rule : th:thm -&gt; thm</div>
<div class="tip" id="fs20">val eqt_intro_rule : th:thm -&gt; thm</div>
<div class="tip" id="fs21">val eta_conv : tm:term -&gt; thm</div>
<div class="tip" id="fs22">val eval_add_conv : tm:term -&gt; thm</div>
<div class="tip" id="fs23">val eval_even_conv : tm:term -&gt; thm</div>
<div class="tip" id="fs24">val eval_exp_conv : tm:term -&gt; thm</div>
<div class="tip" id="fs25">val eval_ge_conv : tm:term -&gt; thm</div>
<div class="tip" id="fs26">val eval_gt_conv : tm:term -&gt; thm</div>
<div class="tip" id="fs27">val eval_le_conv : tm:term -&gt; thm</div>
<div class="tip" id="fs28">val eval_lt_conv : tm:term -&gt; thm</div>
<div class="tip" id="fs29">val parse_term : x:string -&gt; term</div>
<div class="tip" id="fs30">val eval_mult_conv : tm:term -&gt; thm</div>
<div class="tip" id="fs31">val eval_nat_eq_conv : tm:term -&gt; thm</div>
<div class="tip" id="fs32">val eval_odd_conv : tm:term -&gt; thm</div>
<div class="tip" id="fs33">val eval_pre_conv : tm:term -&gt; thm</div>
<div class="tip" id="fs34">val eval_sub_conv : tm:term -&gt; thm</div>
<div class="tip" id="fs35">val eval_suc_conv : tm:term -&gt; thm</div>
<div class="tip" id="fs36">val exists_rule : tm1:term * tm2:term -&gt; th:thm -&gt; thm</div>
<div class="tip" id="fs37">val gen_rule : v:term -&gt; th:thm -&gt; thm</div>
<div class="tip" id="fs38">val imp_antisym_rule : th01:thm -&gt; th02:thm -&gt; thm</div>
<div class="tip" id="fs39">val imp_trans_rule : tha:thm -&gt; thb:thm -&gt; thm</div>
<div class="tip" id="fs40">val list_gen_rule : tms:term list -&gt; th:thm -&gt; thm</div>
<div class="tip" id="fs41">val list_imp_trans_rule : ths:thm list -&gt; thm</div>
<div class="tip" id="fs42">val list_spec_rule : tms:term list -&gt; th:thm -&gt; thm</div>
<div class="tip" id="fs43">val mk_bin_rule : f:term -&gt; th1:thm -&gt; th2:thm -&gt; thm</div>
<div class="tip" id="fs44">val mk_bin1_rule : f:term -&gt; th1:thm -&gt; tm2:term -&gt; thm</div>
<div class="tip" id="fs45">val mk_bin2_rule : f:term -&gt; tm1:term -&gt; th2:thm -&gt; thm</div>
<div class="tip" id="fs46">val mk_conj_rule : tha:thm -&gt; thb:thm -&gt; thm</div>
<div class="tip" id="fs47">val mk_conj1_rule : tha:thm -&gt; tm:term -&gt; thm</div>
<div class="tip" id="fs48">val mk_conj2_rule : tm:term -&gt; th:thm -&gt; thm</div>
<div class="tip" id="fs49">val mk_disj_rule : tha:thm -&gt; thb:thm -&gt; thm</div>
<div class="tip" id="fs50">val mk_disj1_rule : th:thm -&gt; tm:term -&gt; thm</div>
<div class="tip" id="fs51">val mk_disj2_rule : tm:term -&gt; th:thm -&gt; thm</div>
<div class="tip" id="fs52">val mk_eq_rule : tha:thm -&gt; thb:thm -&gt; thm</div>
<div class="tip" id="fs53">val mk_eq1_rule : tha:thm -&gt; tm:term -&gt; thm</div>
<div class="tip" id="fs54">val mk_eq2_rule : tm:term -&gt; thb:thm -&gt; thm</div>
<div class="tip" id="fs55">val mk_exists_rule : v:term -&gt; th:thm -&gt; thm</div>
<div class="tip" id="fs56">val mk_forall_rule : v:term -&gt; th:thm -&gt; thm</div>
<div class="tip" id="fs57">val mk_imp_rule : tha:thm -&gt; thb:thm -&gt; thm</div>
<div class="tip" id="fs58">val mk_imp1_rule : th:thm -&gt; tm:term -&gt; thm</div>
<div class="tip" id="fs59">val mk_imp2_rule : tm:term -&gt; th:thm -&gt; thm</div>
<div class="tip" id="fs60">val mk_not_rule : th:thm -&gt; thm</div>
<div class="tip" id="fs61">val mk_pair_rule : th1:thm -&gt; th2:thm -&gt; thm</div>
<div class="tip" id="fs62">val mk_pair1_rule : th1:thm -&gt; tm:term -&gt; thm</div>
<div class="tip" id="fs63">val mk_pair2_rule : tm:term -&gt; th2:thm -&gt; thm</div>
<div class="tip" id="fs64">val mk_select_rule : v:term -&gt; th:thm -&gt; thm</div>
<div class="tip" id="fs65">val mk_uexists_rule : v:term -&gt; th:thm -&gt; thm</div>
<div class="tip" id="fs66">val not_elim_rule : th:thm -&gt; thm</div>
<div class="tip" id="fs67">val not_intro_rule : th:thm -&gt; thm</div>
<div class="tip" id="fs68">val prove_asm_rule : th01:thm -&gt; th02:thm -&gt; thm</div>
<div class="tip" id="fs69">val select_rule : th:thm -&gt; thm</div>
<div class="tip" id="fs70">val spec_all_rule : th:thm -&gt; thm</div>
<div class="tip" id="fs71">val sym_conv : tm:term -&gt; thm</div>
<div class="tip" id="fs72">val undisch_rule : th:thm -&gt; thm</div>

        </div>
        <div class="span1"></div>
      </div>
    </div>
  </body>
</html>
